package crypto

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/binary"
	"math/big"
)

// VRF (Verifiable Random Function) implementation
// This is a simplified implementation for demonstration purposes

// VRFProof represents a proof of a VRF output
type VRFProof struct {
	Hash      Hash   // The VRF output hash
	Signature []byte // The signature proving the hash was generated by the key holder
}

// GenerateVRF generates a VRF output and proof for a given input
func (kp *KeyPair) GenerateVRF(input []byte) (*VRFProof, error) {
	// Sign the input to get a deterministic but unpredictable output
	signature, err := kp.Sign(input)
	if err != nil {
		return nil, err
	}
	
	// Use the signature to derive a hash
	h := hmac.New(sha256.New, signature)
	h.Write(input)
	hashBytes := h.Sum(nil)
	
	var hash Hash
	copy(hash[:], hashBytes)
	
	return &VRFProof{
		Hash:      hash,
		Signature: signature,
	}, nil
}

// VerifyVRF verifies a VRF proof
func VerifyVRF(publicKeyBytes []byte, input []byte, proof *VRFProof) (bool, error) {
	// Verify the signature
	valid, err := VerifySignature(publicKeyBytes, input, proof.Signature)
	if err != nil || !valid {
		return false, err
	}
	
	// Recompute the hash using the signature
	h := hmac.New(sha256.New, proof.Signature)
	h.Write(input)
	hashBytes := h.Sum(nil)
	
	var expectedHash Hash
	copy(expectedHash[:], hashBytes)
	
	// Check if the hash matches
	return proof.Hash.Equal(expectedHash), nil
}

// VRFToInt converts a VRF hash to an integer in the range [0, max)
func VRFToInt(hash Hash, max uint64) uint64 {
	// Convert the first 8 bytes of the hash to a uint64
	num := binary.BigEndian.Uint64(hash[:8])
	
	// Ensure the result is in the range [0, max)
	return num % max
}

// VRFToBigInt converts a VRF hash to a big integer
func VRFToBigInt(hash Hash) *big.Int {
	return new(big.Int).SetBytes(hash[:])
}
